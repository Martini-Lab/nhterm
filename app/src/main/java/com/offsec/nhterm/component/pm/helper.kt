package com.offsec.nhterm.component.pm

import com.offsec.nhterm.App
import io.nhterm.R
import io.nhterm.component.ComponentManager
import io.nhterm.component.config.NeoTermPath
import com.offsec.nhterm.framework.NeoTermDatabase
import io.nhterm.utils.NLog
import java.io.File
import java.net.URL
import java.nio.file.Files
import java.nio.file.Paths

object SourceHelper {
  fun syncSource() {
    val sourceManager = ComponentManager.getComponent<_root_ide_package_.com.offsec.nhterm.component.pm.PackageComponent>().sourceManager
    syncSource(sourceManager)
  }

  fun syncSource(sourceManager: SourceManager) {
    val content = buildString {
      this.append("# Generated by NeoTerm-Preference\n")
      sourceManager.getEnabledSources()
        .joinTo(this, "\n") { "deb [trusted=yes] ${it.url} ${it.repo}\n" }
    }
    kotlin.runCatching {
      Files.write(Paths.get(NeoTermPath.SOURCE_FILE), content.toByteArray())
    }
  }

  fun detectSourceFiles(): List<File> {
    val sourceManager = ComponentManager.getComponent<_root_ide_package_.com.offsec.nhterm.component.pm.PackageComponent>().sourceManager
    val sourceFiles = ArrayList<File>()
    try {
      val prefixes = sourceManager.getEnabledSources()
        .map { detectSourceFilePrefix(it) }
        .filter { it.isNotEmpty() }

      File(NeoTermPath.PACKAGE_LIST_DIR)
        .listFiles()
        .filterTo(sourceFiles) { file ->
          prefixes.filter { file.name.startsWith(it) }
            .count() > 0
        }
    } catch (e: Exception) {
      sourceFiles.clear()
      NLog.e("PM", "Failed to detect source files: ${e.localizedMessage}")
    }

    return sourceFiles
  }

  fun detectSourceFilePrefix(source: _root_ide_package_.com.offsec.nhterm.component.pm.Source): String {
    try {
      val url = URL(source.url)
      val builder = StringBuilder(url.host)
      if (url.port != -1) {
        builder.append(":${url.port}")
      }

      val path = url.path
      if (path != null && path.isNotEmpty()) {
        builder.append("_")
        val fixedPath = path.replace("/", "_").substring(1) // skip the last '/'
        builder.append(fixedPath)
      }
      builder.append("_dists_${source.repo.replace(" ".toRegex(), "_")}_binary-")
      return builder.toString()
    } catch (e: Exception) {
      NLog.e("PM", "Failed to detect source file prefix: ${e.localizedMessage}")
      return ""
    }
  }
}

class SourceManager internal constructor() {
  private val database = _root_ide_package_.com.offsec.nhterm.framework.NeoTermDatabase.instance("sources")

  init {
    if (database.findAll<_root_ide_package_.com.offsec.nhterm.component.pm.Source>(
            _root_ide_package_.com.offsec.nhterm.component.pm.Source::class.java).isEmpty()) {
      _root_ide_package_.com.offsec.nhterm.App.get().resources.getStringArray(R.array.pref_package_source_values)
        .forEach {
          database.saveBean(
              _root_ide_package_.com.offsec.nhterm.component.pm.Source(
                  it,
                  "stable main",
                  true
              )
          )
        }
    }
  }

  fun addSource(sourceUrl: String, repo: String, enabled: Boolean) {
    database.saveBean(
        _root_ide_package_.com.offsec.nhterm.component.pm.Source(
            sourceUrl,
            repo,
            enabled
        )
    )
  }

  fun removeSource(sourceUrl: String) {
    database.deleteBeanByWhere(_root_ide_package_.com.offsec.nhterm.component.pm.Source::class.java, "url == '$sourceUrl'")
  }

  fun updateAll(sources: List<_root_ide_package_.com.offsec.nhterm.component.pm.Source>) {
    database.dropAllTable()
    database.saveBeans(sources)
  }

  fun getAllSources(): List<_root_ide_package_.com.offsec.nhterm.component.pm.Source> {
    return database.findAll(_root_ide_package_.com.offsec.nhterm.component.pm.Source::class.java)
  }

  fun getEnabledSources(): List<_root_ide_package_.com.offsec.nhterm.component.pm.Source> {
    return getAllSources().filter { it.enabled }
  }

  fun getMainPackageSource(): String {
    return getEnabledSources()
      .map { it.repo }
      .singleOrNull { it.trim() == "stable main" }
      ?: NeoTermPath.DEFAULT_MAIN_PACKAGE_SOURCE
  }

  fun applyChanges() {
    database.vacuum()
  }
}

